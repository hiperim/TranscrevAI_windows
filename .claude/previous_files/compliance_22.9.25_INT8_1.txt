# TRANSCREVAI PROJECT COMPLIANCE RULES - UPDATED FOR PRODUCTION
*Enhanced for systematic validation, error prevention, and MCP Gemini integration*

**MANDATORY ADHERENCE**: All TranscrevAI development must comply with these rules. Violations will cause system instability and performance degradation.

---

## CRITICAL INTEGRATION REQUIREMENTS (NEW)

### Rule 0: Progressive Loading Integration (CRITICAL FIX NEEDED)
- **Integration Gap**: load_model_progressive() exists but NOT connected to main.py 
- **Current Problem**: main.py uses standard load_model() causing 4.1GB memory usage
- **Required Action**: Modify main.py to use progressive loading for browser safety
- **Memory Target**: 1.5GB realistic peak (not 600MB optimistic) with browser compatibility
- **Implementation**: Connect progressive loading to WebSocket progress reporting

**VALIDATION**: Use Gemini MCP to analyze integration points between whisper_onnx_manager.py and main.py. Document exact code modifications needed.

### Rule 0.1: MCP Gemini Integration Strategy
- **Strategic Usage**: Reserve Gemini's 100 daily requests for multi-file analysis and complex integrations
- **High-Value Queries**: System-wide analysis, integration gaps, performance bottlenecks
- **Avoid Waste**: Don't use Gemini for single-file analysis under 50KB or simple documentation
- **Token Conservation**: Group related files in single queries (@src/ rather than individual files)

**VALIDATION**: Track Gemini usage efficiency - >80% of queries must provide actionable implementation details.

---

## CORE PERFORMANCE REQUIREMENTS

### Rule 1: Audio Processing Performance Standards (UPDATED REALISTIC TARGETS)
- **Processing Speed**: Target 0.7s processing time per 1s of recorded audio (adjusted from 0.5s for realism)
- **Accuracy Target**: Maintain ≥90% accuracy in both transcription and diarization (reduced from 95% for achievability)
- **Language Optimization**: PT-BR (Portuguese Brazilian) exclusive optimization
- **Model Restriction**: Use ONLY "medium" model for all operations
- **Conversation Focus**: Optimize specifically for conversational audio patterns

**VALIDATION**: Test with data/recordings/ benchmark files. Accept 0.7s ratio as compliant given hardware constraints.

### Rule 2: Speaker Diarization Constraints
- **Dynamic Speaker Detection**: NEVER presume fixed number of speakers
- **Adaptive Processing**: Handle variable speaker counts per audio file
- **Real-World Optimization**: Optimize for actual usage patterns, not theoretical scenarios

**VALIDATION**: Use benchmark files in data/recordings/ - compare with expected results in benchmark_*.txt files.

### Rule 3: System Stability Requirements (UPDATED FOR BROWSER COMPATIBILITY)
- **Browser Safety**: NEVER exceed 2GB browser memory limit - emergency mode at 1.8GB
- **Progressive Loading**: Implement load_model_progressive() to prevent browser crashes
- **Memory Monitoring**: Real-time monitoring with graceful degradation
- **Rollback Capability**: Maintain ability to revert to standard loading if progressive fails

**VALIDATION**: Test in Chrome/Edge with memory monitoring. Progressive loading must prevent browser freezing.

---

## RESOURCE OPTIMIZATION REQUIREMENTS (UPDATED)

### Rule 4-5: Memory Management (REALISTIC TARGETS)
- **RAM Target**: ≤1.5GB peak usage (realistic vs 600MB optimistic) for FP16 progressive loading
- **Memory Efficiency**: Use progressive loading to stay under browser 2GB limit
- **Browser Compatibility**: Keep significant margin below browser memory limits
- **Emergency Prevention**: Normal operation should never trigger emergency mode

**VALIDATION**: Monitor actual memory usage during progressive loading. 1.5GB or lower = compliant.

### Rule 6-8: Language and Model Optimization
- **Exclusive PT-BR Focus**: All improvements and corrections for Portuguese Brazilian only
- **Single Model Strategy**: Use exclusively "medium" model for Portuguese Brazilian
- **No Multi-Language Support**: Remove or disable any multi-language capabilities

**VALIDATION**: Audit codebase for PT-BR exclusive optimization with Gemini multi-file analysis.

### Rule 9: Performance Optimization Strategy (INTEGRATION-FOCUSED)
- **Integration Priority**: Connect existing optimizations before creating new ones
- **Progressive Implementation**: Use load_model_progressive() as primary loading method
- **Measurable Improvements**: Implement only optimizations with quantifiable benefits
- **Browser Stability**: All optimizations must maintain browser compatibility

**VALIDATION**: Measure integration success rate and browser stability improvement.

---

## TECHNICAL IMPLEMENTATION STANDARDS (UPDATED)

### Rule 10: Smart Model Management (PROGRESSIVE LOADING PRIORITY)
- **Progressive Loading**: Implement load_model_progressive() as default method
- **WebSocket Integration**: Real-time progress reporting during model loading
- **Local Caching**: Cache models locally after first download with HuggingFace optimization
- **Fallback Safety**: Graceful fallback to standard loading if progressive fails

**VALIDATION**: Verify progressive loading integration in main.py and WebSocket progress reporting.

### Rule 11-12: System Resource Monitoring (BROWSER-AWARE)
- **Memory Monitoring**: Real-time monitoring with browser-safe thresholds
- **Progressive Processing**: Use progressive loading to prevent browser freezing
- **Performance Tracking**: Monitor 0.7s per 1s audio ratio (realistic target)
- **Browser Integration**: Prevent memory pressure from affecting browser stability

**VALIDATION**: Test system resource impact with real browser sessions and memory monitoring.

### Rule 13: WebSocket Communication Enhancement (PROGRESSIVE LOADING INTEGRATION)
- **Progressive Progress**: Real-time updates during multi-stage progressive loading
- **Memory Status**: Report memory usage and loading stages to user
- **Loading Phases**: "Downloading encoder (50%)" → "Processing audio" → "Loading decoder (75%)" → "Generating text (90%)"
- **Browser Stability**: Maintain WebSocket connection during memory-intensive operations

**VALIDATION**: Test WebSocket stability during progressive loading with real audio files.

### Rule 14: Implementation Testing Protocol (INTEGRATION-FOCUSED)
- **Integration Testing**: Test progressive loading integration with main.py before other features
- **Real Audio Testing**: Validate with benchmark files in data/recordings/
- **Memory Monitoring**: Monitor browser memory usage during all operations
- **Performance Validation**: Confirm 0.7s ratio achievable with progressive loading

**VALIDATION**: Mandatory progressive loading integration testing before other implementations.

### Rule 15: Code Quality Standards (MCP GEMINI INTEGRATION)
- **MCP Analysis**: Use Gemini for complex multi-file type checking and integration analysis
- **Pylance Compatibility**: Maintain Pylance adequations and standards
- **Integration Safety**: Ensure progressive loading integration doesn't break existing functionality

**VALIDATION**: Use Gemini MCP to validate complex integrations and type safety across multiple files.

---

## INTEGRATION AND DEPLOYMENT REQUIREMENTS (NEW SECTION)

### Rule 16: Progressive Loading Implementation (CRITICAL)
- **Main.py Integration**: Modify main.py to call load_model_progressive() instead of load_model()
- **WebSocket Integration**: Implement progress reporting for progressive loading stages
- **Memory Safety**: Prevent browser memory overflow through progressive approach
- **Error Handling**: Graceful fallback to standard loading when progressive fails

**VALIDATION**: Use Gemini MCP to analyze integration points and validate implementation completeness.

### Rule 17: Browser Compatibility Requirements (NEW)
- **Memory Limits**: Stay well under 2GB browser memory limit (target 1.5GB peak)
- **Progressive UI**: Show loading progress to prevent user perception of freezing
- **Connection Stability**: Maintain WebSocket during memory-intensive operations
- **Error Recovery**: Graceful degradation when memory pressure detected

**VALIDATION**: Test in production browsers with memory monitoring and user experience validation.

### Rule 18: MCP Gemini Usage Protocol (NEW)
- **Strategic Queries**: Use Gemini for multi-file analysis and complex integration issues
- **Token Management**: Conserve daily 100 requests for high-value analysis
- **Integration Focus**: Prioritize system integration queries over simple code analysis
- **Documentation**: Track Gemini query efficiency and integration success rates

**VALIDATION**: Monitor Gemini usage patterns and integration implementation success rate.

---

## HARDWARE AND COMPATIBILITY REQUIREMENTS (UPDATED)

### Rule 19: Hardware Optimization (PROGRESSIVE LOADING AWARE)
- **Minimum Specifications**: Optimize for 4 CPU cores and 8GB RAM minimum
- **Progressive Loading**: Use progressive approach to work within hardware constraints
- **Browser Memory**: Account for browser overhead in memory calculations (leave 2GB+ available)

**VALIDATION**: Test progressive loading on minimum hardware specifications.

### Rule 20: System Optimization (INTEGRATION-FOCUSED)
- **Progressive Implementation**: Prioritize connecting existing components over new optimizations
- **Integration Validation**: Use Gemini MCP for complex integration analysis
- **Browser Compatibility**: Ensure optimizations work within browser memory constraints

**VALIDATION**: Use Gemini for system-wide integration validation and browser compatibility testing.

---

## PROJECT ORGANIZATION AND MAINTENANCE (UPDATED)

### Rule 21: Integration Priority (NEW)
- **Progressive Loading First**: Complete progressive loading integration before other optimizations
- **Component Connection**: Connect existing optimizations before creating new ones
- **System Integration**: Use MCP Gemini to identify and resolve integration gaps
- **Working Functionality**: Prioritize 100% working basic functionality over advanced features

**VALIDATION**: Audit integration completeness with MCP Gemini multi-file analysis.

### Rule 22: Documentation and Tracking (MCP INTEGRATED)
- **Fixes Documentation**: Update fixes.txt with integration progress and Gemini insights (max 25,000 tokens)
- **MCP Usage Tracking**: Document Gemini query efficiency and integration success
- **Integration Status**: Track progressive loading integration completion status
- **Performance Metrics**: Document realistic performance targets and achievements

**VALIDATION**: Use Gemini MCP for documentation completeness and integration status validation.

### Rule 23: Validation Testing Protocol (INTEGRATION-FIRST)
- **Progressive Loading Testing**: Test progressive loading integration before other features
- **Real Audio Validation**: Use data/recordings/ benchmark files for integration testing
- **Browser Testing**: Validate memory usage and stability in production browsers
- **Integration Completeness**: Use MCP Gemini to validate end-to-end integration

**VALIDATION**: Mandatory progressive loading integration validation before other implementations.

---

## SYSTEM INTEGRATION REQUIREMENTS (UPDATED)

### Rule 24: Application Integration (PROGRESSIVE LOADING FOCUSED)
- **Main Pipeline**: Ensure main.py uses progressive loading for primary transcription path
- **Component Coordination**: All components must work with progressive loading approach
- **Memory Coordination**: Unified memory management supporting progressive loading

**VALIDATION**: Use MCP Gemini to analyze complete system integration and identify gaps.

### Rule 25: Storage and Model Optimization (PROGRESSIVE-AWARE)
- **Progressive Model Management**: Optimize model loading for progressive approach
- **Memory Streaming**: Support model streaming during progressive loading
- **Browser Storage**: Account for browser storage limitations and memory pressure

**VALIDATION**: Verify progressive loading compatibility with storage and model systems.

### Rule 26: Deployment and Review (INTEGRATION-COMPLETE)
- **Progressive Loading Deployment**: Ensure progressive loading works in production environment
- **Browser Compatibility**: Test deployment in multiple browser environments
- **Integration Completeness**: Complete system integration before Docker packaging

**VALIDATION**: Test complete integrated system before Docker containerization.

---

## CRITICAL SUCCESS METRICS (UPDATED)

### Integration Success Metrics
- **Progressive Loading**: load_model_progressive() actively used in main.py (Target: 100%)
- **Memory Compliance**: Peak usage ≤1.5GB during progressive loading (Target: 100%)
- **Browser Stability**: No emergency mode during normal operation (Target: 100%)
- **Pipeline Completeness**: End-to-end transcription working with real audio (Target: 100%)

### MCP Gemini Efficiency Metrics
- **Query Success Rate**: >80% of Gemini queries provide actionable implementation details
- **Token Conservation**: <75 daily requests used for maximum efficiency
- **Integration Resolution**: Each Gemini session resolves ≥1 critical integration gap
- **Problem Identification**: >90% of integration gaps identified through MCP analysis

### Performance Compliance (Realistic Targets)
- **Processing Speed**: ≤0.7s processing per 1s audio with progressive loading (Target: 100%)
- **Memory Efficiency**: Peak 1.5GB vs current 4.1GB - 63% reduction (Target: 100%)
- **Browser Compatibility**: Stable operation in Chrome/Edge under memory pressure (Target: 100%)
- **Accuracy Maintenance**: ≥90% transcription/diarization accuracy (Target: 100%)

---

## COMPLIANCE VALIDATION FRAMEWORK (UPDATED)

### Automatic Integration Checkpoints
1. **Progressive Loading Integration**: main.py uses load_model_progressive() as primary method
2. **Memory Management**: Peak usage ≤1.5GB with progressive loading approach
3. **Browser Compatibility**: Stable operation under 2GB browser memory limit
4. **WebSocket Integration**: Progress reporting during progressive loading stages
5. **MCP Usage**: Strategic Gemini usage for complex integration analysis
6. **Real Audio Testing**: Benchmark validation with data/recordings/ files

### Integration Violation Consequences
- **Memory Overflow**: Immediate implementation of progressive loading
- **Browser Instability**: Rollback to memory-safe configuration
- **Integration Failure**: Use MCP Gemini to identify and resolve gaps
- **Performance Degradation**: Optimize progressive loading implementation

### Integration Success Metrics
- **Progressive Integration**: load_model_progressive() connection to main.py (Target: 100%)
- **Memory Optimization**: 1.5GB peak vs 4.1GB current - browser safe (Target: 100%)
- **Pipeline Completeness**: End-to-end transcription functionality (Target: 100%)
- **Browser Stability**: Zero crashes during progressive loading (Target: 100%)
- **MCP Efficiency**: Strategic Gemini usage with high integration success rate (Target: 80%+)

**This compliance framework ensures systematic validation of TranscrevAI integration progress with focus on connecting existing components to achieve 100% working functionality through strategic MCP Gemini usage.**