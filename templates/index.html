<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TranscrevAI - Simple Transcription</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            padding: 40px;
            max-width: 600px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5rem;
            font-weight: 700;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1rem;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-row {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .select {
            padding: 12px 16px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 1rem;
            background: white;
            margin: 0 0.5rem;
        }

        .button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            min-width: 100px;
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .record-btn {
            background: linear-gradient(45deg, #66bb6a, #43a047);
            color: white;
        }

        .pause-btn {
            background: linear-gradient(45deg, #ffa726, #fb8c00);
            color: white;
        }

        .stop-btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
        }

        .button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .status {
            text-align: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            margin: 20px 0;
            font-weight: 500;
        }

        .waveform {
            height: 80px;
            background: #f1f3f4;
            border-radius: 8px;
            margin: 20px 0;
            position: relative;
            overflow: hidden;
        }

        .waveform-content {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
        }

        .progress {
            margin: 20px 0;
        }

        .progress-item {
            margin-bottom: 15px;
        }

        .progress-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e1e5e9;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }

        .results {
            max-height: 300px;
            overflow-y: auto;
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease;
        }

        .results.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #4caf50;
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
            z-index: 1000;
            max-width: 400px;
        }

        .notification.show {
            opacity: 1;
            transform: translateX(0);
        }

        .notification.error {
            background: #f44336;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
                margin: 10px;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .control-row {
                flex-direction: column;
            }
            
            .select, .button {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>TranscrevAI</h1>
        <p class="subtitle">Real-time Audio Transcription with Speaker Diarization</p>
        
        <div class="controls">
            <div class="control-row">
                <select id="language" class="select">
                    <option value="" disabled selected>[Select Language]</option>
                    <option value="en">English</option>
                    <option value="pt">Portuguese</option>
                    <option value="es">Spanish</option>
                </select>
                
                <select id="format" class="select">
                    <option value="wav">.WAV</option>
                    <option value="mp4">.MP4</option>
                </select>
            </div>
            
            <div class="control-row">
                <button id="recordBtn" class="button record-btn">Record</button>
                <button id="pauseBtn" class="button pause-btn" disabled>Pause</button>
                <button id="stopBtn" class="button stop-btn" disabled>Stop</button>
            </div>
        </div>
        
        <div id="status" class="status">Ready to record</div>
        
        <div id="waveform" class="waveform">
            <div id="waveform-content" class="waveform-content">Audio visualization will appear here</div>
        </div>
        
        <div id="progress" class="progress">
            <div class="progress-item">
                <div class="progress-label">
                    <span>Transcription</span>
                    <span id="transcription-percent">0%</span>
                </div>
                <div class="progress-bar">
                    <div id="transcription-progress" class="progress-fill"></div>
                </div>
            </div>
            
            <div class="progress-item">
                <div class="progress-label">
                    <span>Diarization</span>
                    <span id="diarization-percent">0%</span>
                </div>
                <div class="progress-bar">
                    <div id="diarization-progress" class="progress-fill"></div>
                </div>
            </div>
        </div>
        
        <div id="results" class="results">
            <h3>Results will appear here</h3>
        </div>
    </div>
    
    <div id="notification" class="notification"></div>

    <script>
        class TranscrevAI {
            constructor() {
                this.ws = null;
                this.sessionId = this.generateSessionId();
                this.isRecording = false;
                this.isPaused = false;
                
                // Get DOM elements
                this.recordBtn = document.getElementById('recordBtn');
                this.pauseBtn = document.getElementById('pauseBtn');
                this.stopBtn = document.getElementById('stopBtn');
                this.languageEl = document.getElementById('language');
                
                // CRITICAL FIX: Safe format element initialization
                this.formatEl = document.getElementById('format');
                if (!this.formatEl) {
                    console.warn('Format selector not found, using default WAV format');
                    // Create a mock element to prevent further errors
                    this.formatEl = { value: 'wav' };
                }
                
                this.waveformEl = document.getElementById('waveform');
                this.waveformContent = document.getElementById('waveform-content');
                this.progressEl = document.getElementById('progress');
                this.transcriptionProgress = document.getElementById('transcription-progress');
                this.diarizationProgress = document.getElementById('diarization-progress');
                this.transcriptionPercent = document.getElementById('transcription-percent');
                this.diarizationPercent = document.getElementById('diarization-percent');
                this.statusEl = document.getElementById('status');
                this.resultsEl = document.getElementById('results');
                this.notificationEl = document.getElementById('notification');
                
                this.setupEventListeners();
                this.connect();
            }
            
            generateSessionId() {
                return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            }
            
            setupEventListeners() {
                this.recordBtn.addEventListener('click', () => this.startRecording());
                this.pauseBtn.addEventListener('click', () => this.togglePause());
                this.stopBtn.addEventListener('click', () => this.stopRecording());
            }
            
            connect() {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/ws/${this.sessionId}`;
                
                this.ws = new WebSocket(wsUrl);
                
                this.ws.onopen = () => {
                    console.log('Connected to server');
                    this.updateStatus('Connected - Ready to record');
                };
                
                this.ws.onclose = () => {
                    console.log('Disconnected from server');
                    this.updateStatus('Disconnected - Please refresh the page');
                    setTimeout(() => this.connect(), 3000);
                };
                
                this.ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    this.showError('Connection error. Please refresh the page.');
                };
                
                this.ws.onmessage = (event) => {
                    const message = JSON.parse(event.data);
                    this.handleMessage(message);
                };
            }
            
            handleMessage(message) {
                switch (message.type) {
                    case 'recording_started':
                        this.isRecording = true;
                        this.updateButtons();
                        this.updateStatus('Recording...');
                        break;
                        
                    case 'recording_stopped':
                        this.isRecording = false;
                        this.isPaused = false;
                        this.updateButtons();
                        this.updateStatus('Processing audio...');
                        break;
                        
                    case 'recording_paused':
                        this.isPaused = true;
                        this.updateButtons();
                        this.updateStatus('Recording paused');
                        break;
                        
                    case 'recording_resumed':
                        this.isPaused = false;
                        this.updateButtons();
                        this.updateStatus('Recording...');
                        break;
                        
                    case 'audio_level':
                        this.updateWaveform(message.level);
                        break;
                        
                    case 'progress':
                        this.updateProgress(message.transcription || 0, message.diarization || 0);
                        break;
                        
                    case 'model_download_start':
                        this.updateStatus(`Downloading ${message.model} model for ${message.language}...`);
                        break;
                        
                    case 'model_download_complete':
                        this.updateStatus('Model ready - Processing audio...');
                        break;
                        
                    case 'model_download_error':
                        this.showError(`Model download failed: ${message.message}`);
                        this.resetState();
                        break;
                        
                    case 'system_download_start':
                        this.updateStatus(`${message.message || 'Downloading required components...'}`);
                        break;
                        
                    case 'system_download_progress':
                        if (message.progress) {
                            this.updateStatus(`${message.message || 'Downloading...'} (${message.progress}%)`);
                        } else {
                            this.updateStatus(message.message || 'Downloading...');
                        }
                        break;
                        
                    case 'system_download_complete':
                        this.updateStatus(`${message.message || 'Download completed'}`);
                        setTimeout(() => {
                            if (!this.isRecording) {
                                this.updateStatus('Connected - Ready to record');
                            }
                        }, 2000);
                        break;
                        
                    case 'processing_complete':
                        this.handleResults(message);
                        break;
                        
                    case 'error':
                        this.showError(message.message);
                        this.resetState();
                        break;
                        
                    default:
                        console.log('Unknown message type:', message.type);
                }
            }
            
            updateButtons() {
                this.recordBtn.disabled = this.isRecording;
                this.pauseBtn.disabled = !this.isRecording;
                this.stopBtn.disabled = !this.isRecording;
                
                if (this.isPaused) {
                    this.pauseBtn.textContent = 'Resume';
                } else {
                    this.pauseBtn.textContent = 'Pause';
                }
            }
            
            updateStatus(text) {
                this.statusEl.textContent = text;
            }
            
            updateWaveform(level) {
                if (this.isRecording && !this.isPaused) {
                    const intensity = Math.floor(level * 255);
                    const color = `rgb(${intensity}, ${Math.floor(intensity * 0.7)}, ${Math.floor(intensity * 0.3)})`;
                    this.waveformContent.style.background = `linear-gradient(90deg, ${color} ${level * 100}%, #f1f3f4 ${level * 100}%)`;
                    this.waveformContent.textContent = `Recording... (Level: ${Math.floor(level * 100)}%)`;
                }
            }
            
            updateProgress(transcription, diarization) {
                this.transcriptionProgress.style.width = `${transcription}%`;
                this.diarizationProgress.style.width = `${diarization}%`;
                this.transcriptionPercent.textContent = `${transcription}%`;
                this.diarizationPercent.textContent = `${diarization}%`;
            }
            
            handleResults(data) {
                this.updateStatus('Processing complete!');
                this.resetState();
                
                let resultsHTML = '<h3>Transcription Results</h3>';
                
                if (data.transcription_data && data.transcription_data.length > 0) {
                    resultsHTML += '<div style="margin: 15px 0;"><strong>Transcription:</strong></div>';
                    
                    // ENHANCED: Group transcription text by speaker for better readability
                    const groupedBySpeaker = {};
                    
                    // Group segments by speaker with temporal proximity
                    data.transcription_data.forEach(item => {
                        const speakerName = (item.speaker || 'Speaker_1').replace('_', ' ');
                        const text = item.text || item.content || '';
                        
                        if (text.trim()) {
                            if (!groupedBySpeaker[speakerName]) {
                                groupedBySpeaker[speakerName] = {
                                    texts: [],
                                    firstTime: item.start || 0,
                                    lastTime: item.end || 0
                                };
                            }
                            
                            groupedBySpeaker[speakerName].texts.push(text.trim());
                            
                            // Update timing info
                            if (item.start !== undefined && item.start < groupedBySpeaker[speakerName].firstTime) {
                                groupedBySpeaker[speakerName].firstTime = item.start;
                            }
                            if (item.end !== undefined && item.end > groupedBySpeaker[speakerName].lastTime) {
                                groupedBySpeaker[speakerName].lastTime = item.end;
                            }
                        }
                    });
                    
                    // Display grouped results
                    Object.keys(groupedBySpeaker).sort().forEach(speakerName => {
                        const speakerData = groupedBySpeaker[speakerName];
                        const combinedText = speakerData.texts.join(' ').trim();
                        
                        if (combinedText) {
                            const duration = speakerData.lastTime - speakerData.firstTime;
                            const timeInfo = duration > 0 ? ` (${speakerData.firstTime.toFixed(1)}s -> ${speakerData.lastTime.toFixed(1)}s)` : '';
                            
                            resultsHTML += `<div style="margin: 10px 0; padding: 15px; background: white; border-radius: 8px; border-left: 4px solid #007bff;">
                                <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                                    <strong style="color: #007bff; font-size: 1.1em;">${speakerName}:</strong>
                                    <span style="font-size: 0.9em; color: #666;">${timeInfo}</span>
                                </div>
                                <div style="margin-top: 8px; line-height: 1.4; font-size: 1em;">
                                    ${combinedText}
                                </div>
                            </div>`;
                        }
                    });
                    
                    // Fallback: if no grouped text found, show original format
                    if (Object.keys(groupedBySpeaker).length === 0) {
                        data.transcription_data.forEach(item => {
                            const text = item.text || item.content || 'No text';
                            if (text.trim() !== 'No text' && text.trim()) {
                                resultsHTML += `<div style="margin: 10px 0; padding: 10px; background: white; border-radius: 5px;">
                                    <strong>${(item.speaker || 'Speaker_1').replace('_', ' ')}:</strong> ${text}
                                </div>`;
                            }
                        });
                    }
                } else {
                    resultsHTML += '<div>No transcription data available.</div>';
                }
                
                if (data.speakers_detected > 0) {
                    resultsHTML += `<div style="margin: 15px 0;"><strong>Speakers detected:</strong> ${data.speakers_detected}</div>`;
                }
                
                if (data.duration) {
                    resultsHTML += `<div><strong>Duration:</strong> ${Math.round(data.duration)} seconds</div>`;
                }
                
                this.resultsEl.innerHTML = resultsHTML;
                this.resultsEl.classList.add('visible');
                
                // Show file notification if paths are available
                if (data.audio_file || data.srt_file) {
                    this.showFileNotification(data.audio_file, data.srt_file);
                }
            }

            showFileNotification(audioPath, srtPath) {
                let content = `Files saved successfully!\n`;
                
                // Detect format from file extension
                const formatType = audioPath.toLowerCase().endsWith('.mp4') ? 'MP4 Video' : 'WAV Audio';
                content += `${formatType}: ${audioPath}\n`;
                
                if (srtPath) {
                    content += `Subtitles: ${srtPath}`;
                }
                
                this.showNotification(content, 'success');
            }
            
            showNotification(message, type = 'success') {
                this.notificationEl.textContent = message;
                this.notificationEl.className = `notification ${type}`;
                this.notificationEl.classList.add('show');
                
                setTimeout(() => {
                    this.notificationEl.classList.remove('show');
                }, 5000);
            }
            
            showError(message) {
                this.showNotification(message, 'error');
                console.error('Error:', message);
            }
            
            resetState() {
                this.isRecording = false;
                this.isPaused = false;
                this.updateButtons();
                this.waveformContent.style.background = '#f1f3f4';
                this.waveformContent.textContent = 'Audio visualization will appear here';
                this.updateProgress(0, 0);
            }
            
            // CRITICAL FIX: Safe format access with fallback
            startRecording() {
                this.resultsEl.classList.remove('visible');
                
                // Validate language selection
                if (!this.languageEl.value) {
                    this.showError('Please select a language before recording');
                    return;
                }
                
                // Safe format access with fallback
                const formatValue = this.formatEl && this.formatEl.value ? this.formatEl.value : 'wav';
                
                this.send('start_recording', { 
                    language: this.languageEl.value,
                    format: formatValue
                });
            }
            
            togglePause() {
                if (this.isPaused) {
                    this.send('resume_recording');
                } else {
                    this.send('pause_recording');
                }
            }
            
            stopRecording() {
                this.send('stop_recording');
            }
            
            // CRITICAL FIX: Enhanced error handling for WebSocket send
            send(type, data = {}) {
                try {
                    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                        this.ws.send(JSON.stringify({
                            type: type,
                            data: data
                        }));
                    } else {
                        throw new Error('WebSocket is not connected');
                    }
                } catch (error) {
                    console.error('WebSocket send error:', error);
                    this.showError('Connection error. Please refresh the page.');
                    this.resetState();
                }
            }
        }
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            new TranscrevAI();
        });
    </script>
</body>
</html>